<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Advanced Disk Scheduling Simulator (HTML)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width:1000px; margin:18px auto; padding:16px; color:#111; }
    h1 { margin-bottom: 6px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    label { font-weight:600; margin-right:6px; }
    input[type="text"], select { padding:6px 8px; font-size:14px; min-width:220px; }
    button { padding:8px 12px; font-size:14px; cursor:pointer; }
    .panel { margin-top:12px; padding:12px; border-radius:8px; background:#f8f9fb; box-shadow:0 1px 3px rgba(0,0,0,0.06); }
    #canvasWrap { margin-top:12px; border:1px solid #ddd; padding:10px; border-radius:6px; background:white; }
    canvas { width:100%; height:300px; display:block; }
    pre { background:#0f1724; color:#e6eef8; padding:10px; border-radius:6px; overflow:auto; }
    .metrics { margin-top:8px; display:flex; gap:12px; flex-wrap:wrap; }
    .metric { background:#fff; padding:8px 10px; border-radius:6px; border:1px solid #e2e8f0; }
    .small { font-size:13px; color:#444; }
    footer { margin-top:18px; font-size:13px; color:#555; }
  </style>
</head>
<body>
  <h1>Advanced Disk Scheduling Simulator</h1>
  <div class="small">Implements FCFS, SSTF, SCAN, C-SCAN and visualizes head movement (cylinders).</div>

  <div class="panel">
    <div class="row">
      <label for="requests">Requests (comma separated)</label>
      <input id="requests" type="text" value="82,170,43,140,24,16,190" />
      <label for="head">Head pos</label>
      <input id="head" type="text" value="50" style="width:80px" />
      <label for="disk">Disk size</label>
      <input id="disk" type="text" value="200" style="width:80px" />
      <label for="algo">Algorithm</label>
      <select id="algo">
        <option value="fcfs">FCFS</option>
        <option value="sstf">SSTF</option>
        <option value="scan">SCAN</option>
        <option value="cscan">C-SCAN</option>
      </select>
      <button id="runBtn">Run</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div id="canvasWrap">
      <canvas id="chart" width="900" height="300"></canvas>
    </div>

    <div class="metrics">
      <div class="metric"><strong>Servicing Order:</strong><div id="order">-</div></div>
      <div class="metric"><strong>Total Head Movement:</strong><div id="movement">-</div></div>
      <div class="metric"><strong>Average Seek (per request):</strong><div id="avgseek">-</div></div>
    </div>

    <div style="margin-top:12px">
      <strong>Notes:</strong>
      <ul>
        <li class="small">Requests must be integers between 0 and disk-1. Duplicate requests are allowed.</li>
        <li class="small">SCAN moves toward higher cylinders first for the "right" direction used here.</li>
      </ul>
    </div>

    <h3 style="margin-top:12px">Console Output</h3>
    <pre id="console">Ready. Click Run to simulate.</pre>
  </div>

  <footer>
    Export: Copy the servicing order text and movement value for reports. This page works offline in your browser.
  </footer>

<script>
/* -------------------------
   Disk scheduling algorithms
   ------------------------- */

function parseRequests(text) {
  if (!text.trim()) return [];
  return text.split(',')
    .map(s => s.trim())
    .filter(s => s.length > 0)
    .map(s => Number(s))
    .filter(n => Number.isFinite(n));
}

function fcfs(requests, head) {
  const seq = [head, ...requests];
  const movement = seq.slice(0,-1).reduce((acc, cur, i) => acc + Math.abs(cur - seq[i+1]), 0);
  return { sequence: seq, movement };
}

function sstf(requests, head) {
  const req = requests.slice();
  const seq = [head];
  let pos = head;
  while (req.length) {
    let idx = 0;
    let best = Math.abs(req[0] - pos);
    for (let i=1;i<req.length;i++){
      const d = Math.abs(req[i]-pos);
      if (d < best) { best = d; idx = i; }
    }
    seq.push(req[idx]);
    pos = req[idx];
    req.splice(idx,1);
  }
  const movement = seq.slice(0,-1).reduce((acc, cur, i) => acc + Math.abs(cur - seq[i+1]), 0);
  return { sequence: seq, movement };
}

function scan(requests, head, diskSize=200) {
  const left = requests.filter(r => r < head).sort((a,b)=>b-a);  // descending
  const right = requests.filter(r => r >= head).sort((a,b)=>a-b); // ascending
  // move right first, then to end, then back left
  const seq = [head, ...right, diskSize - 1, ...left];
  const movement = seq.slice(0,-1).reduce((acc, cur, i) => acc + Math.abs(cur - seq[i+1]), 0);
  return { sequence: seq, movement };
}

function cscan(requests, head, diskSize=200) {
  const right = requests.filter(r => r >= head).sort((a,b)=>a-b);
  const left = requests.filter(r => r < head).sort((a,b)=>a-b); // ascending
  // move right, go to end, jump to 0, service left
  const seq = [head, ...right, diskSize - 1, 0, ...left];
  const movement = seq.slice(0,-1).reduce((acc, cur, i) => acc + Math.abs(cur - seq[i+1]), 0);
  return { sequence: seq, movement };
}

/* -------------------------
   UI + Drawing helpers
   ------------------------- */

const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');
const consoleEl = document.getElementById('console');
const orderEl = document.getElementById('order');
const movementEl = document.getElementById('movement');
const avgseekEl = document.getElementById('avgseek');

function log(msg) {
  consoleEl.textContent = msg + "\n" + consoleEl.textContent;
}

function clearCanvas() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

/* Draw a simple line chart of sequence vs step */
function drawSequence(seq, diskSize) {
  clearCanvas();
  const W = canvas.width, H = canvas.height;
  const pad = 40;
  const innerW = W - pad*2, innerH = H - pad*2;
  // compute min/max y (cylinders)
  const maxCyl = Math.max(diskSize-1, ...seq);
  const minCyl = Math.min(0, ...seq);
  // axes
  ctx.strokeStyle = "#333";
  ctx.lineWidth = 1;
  ctx.beginPath(); // y axis
  ctx.moveTo(pad, pad);
  ctx.lineTo(pad, H-pad);
  ctx.lineTo(W-pad, H-pad);
  ctx.stroke();

  // labels
  ctx.fillStyle = "#222";
  ctx.font = "12px sans-serif";
  ctx.fillText("Steps →", W/2, H - 8);
  ctx.save();
  ctx.translate(10, H/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText("Cylinder", 0, 0);
  ctx.restore();

  // gridlines and ticks for y
  const ticks = 5;
  for (let i=0;i<=ticks;i++){
    const y = pad + i*(innerH)/ticks;
    const cyl = Math.round(maxCyl - i*(maxCyl-minCyl)/ticks);
    ctx.strokeStyle = "#e6eef8";
    ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(W-pad, y); ctx.stroke();
    ctx.fillStyle = "#333"; ctx.fillText(String(cyl), 4, y+4);
  }

  // map function
  const nx = seq.length;
  const xStep = innerW / Math.max(1, nx-1);
  const yFor = (cyl) => pad + (maxCyl - cyl) * innerH / Math.max(1, (maxCyl - minCyl));

  // draw polyline
  ctx.strokeStyle = "#0b6efd";
  ctx.lineWidth = 2;
  ctx.beginPath();
  seq.forEach((cyl, i) => {
    const x = pad + i * xStep;
    const y = yFor(cyl);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  });
  ctx.stroke();

  // points and labels
  ctx.fillStyle = "#0b6efd";
  ctx.font = "11px sans-serif";
  seq.forEach((cyl,i)=>{
    const x = pad + i*xStep; const y = yFor(cyl);
    ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = "#222"; ctx.fillText(String(cyl), x-10, y-8);
    ctx.fillStyle = "#0b6efd";
  });
}

/* -------------------------
   Run / UI wiring
   ------------------------- */

document.getElementById('runBtn').addEventListener('click', () => {
  const reqText = document.getElementById('requests').value;
  const headText = document.getElementById('head').value;
  const diskText = document.getElementById('disk').value;
  const algo = document.getElementById('algo').value;

  const requests = parseRequests(reqText);
  const head = Number(headText);
  const diskSize = Math.max(1, Number(diskText) || 200);

  // validation
  if (!Number.isFinite(head) || head < 0 || head >= diskSize) {
    alert("Head must be a number between 0 and diskSize-1.");
    return;
  }
  for (const r of requests) {
    if (!Number.isFinite(r) || r < 0 || r >= diskSize) {
      alert("All requests must be integers between 0 and diskSize-1.");
      return;
    }
  }

  let res;
  if (algo === 'fcfs') res = fcfs(requests, head);
  else if (algo === 'sstf') res = sstf(requests, head);
  else if (algo === 'scan') res = scan(requests, head, diskSize);
  else if (algo === 'cscan') res = cscan(requests, head, diskSize);
  else { alert("Unknown algorithm"); return; }

  // Show results
  orderEl.textContent = res.sequence.join(" → ");
  movementEl.textContent = String(res.movement);
  avgseekEl.textContent = (res.movement / Math.max(1, requests.length)).toFixed(2);

  log(`[${new Date().toLocaleTimeString()}] Algo=${algo.toUpperCase()}, Requests=[${requests.join(',')}], Head=${head}, Disk=${diskSize}`);
  log(`Order: ${res.sequence.join(' -> ')}`);
  log(`Total head movement: ${res.movement}`);

  drawSequence(res.sequence, diskSize);
});

/* Reset */
document.getElementById('resetBtn').addEventListener('click', () => {
  document.getElementById('requests').value = "82,170,43,140,24,16,190";
  document.getElementById('head').value = "50";
  document.getElementById('disk').value = "200";
  document.getElementById('algo').value = "fcfs";
  document.getElementById('console').textContent = "Ready. Click Run to simulate.";
  orderEl.textContent = "-";
  movementEl.textContent = "-";
  avgseekEl.textContent = "-";
  clearCanvas();
});

window.addEventListener('load', () => {
  // initial draw (empty)
  clearCanvas();
});
</script>

</body>
</html>
